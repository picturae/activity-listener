{"version":3,"file":"activityListener.js","sources":["../src/activityListener.js"],"sourcesContent":["const activityListener = (function () {\n    // internal state; isRunning - Boolean\n    let isRunning = true\n    // lookup, wrapped callback by eventType\n    const registry = {}\n\n    /**\n     * Execute callback with checks\n     * @private\n     * @param {Function} timer - wrapped callback\n     */\n    const execute = function (callback, delay, event) {\n        if (!isRunning) {\n            return\n        }\n        const tryCatch = function () {\n            try {\n                callback(event)\n            } catch (error) {\n                console.error('activityListener caught faulty callback')\n            }\n        }\n        if (!delay) {\n            tryCatch()\n        } else {\n            setTimeout(tryCatch, delay)\n        }\n    }\n\n    /**\n     * Add or remove EventListeners\n     * @private\n     * @param {String} aim - 'add' | 'remove'\n     * @param {String} type - eventType\n     * @param {Function} callback - external function to call in case of event\n     */\n    const eventHandling = function (aim, type, callback) {\n        const handler = `on${type}`\n        const procedure = registry[type].get(callback).procedure\n        const eventOptions = registry[type].get(callback).options\n        if (handler in window) {\n            window[aim + 'EventListener'](type, procedure, eventOptions)\n        } else if (handler in document) {\n            document[aim + 'EventListener'](type, procedure, eventOptions)\n        } else if (aim === 'add') {\n            console.warn(`activityListener rejected ${type}-event`)\n        }\n    }\n\n    /**\n     * Attach callback to event.\n     * @param {String} type - event type to watch\n     * @param {Function} ahead - to execute first\n     * @param {Function} done - to execute after all\n     * @param {Number} doneDelay - milliseconds to allow regular event-handler to finish\n     */\n    const register = function (type, ahead, done, doneDelay = 50) {\n        const enroll = function (callback, options, delay) {\n            const procedure = function (event) {\n                execute(callback, delay, event)\n            }\n            if (!registry[type]) {\n                registry[type] = new Map()\n            }\n            registry[type].set(callback, {\n                procedure: procedure,\n                options: options,\n            })\n            eventHandling('add', type, callback)\n        }\n        if (ahead) {\n            enroll(ahead, { passive: true, capture: true }, 0)\n        }\n        if (done) {\n            enroll(done, { passive: true, capture: false }, doneDelay)\n        }\n    }\n\n    /**\n     * Detach event/callback pair.\n     * @param {String} type - event type to watch\n     * @param {Function} callback\n     */\n    const erase = function (type, callback) {\n        eventHandling('remove', type, callback)\n        registry[type].delete(callback)\n        if (!registry[type].size) {\n            delete registry[type]\n        }\n    }\n\n    /**\n     * Erase all callbacks, without knowing them :-)\n     */\n    const destroy = function () {\n        Object.keys(registry).forEach((type) => {\n            for (let key of registry[type].keys()) {\n                erase(type, key)\n            }\n        })\n    }\n\n    /**\n     * Expose callbacks\n     */\n    const resume = function () {\n        isRunning = true\n    }\n\n    /**\n     * Block callbacks\n     */\n    const pause = function () {\n        isRunning = false\n    }\n\n    return {\n        debug: () => console.log('registry', registry),\n        clear: destroy, // deprecated\n        destroy: destroy,\n        erase: erase,\n        pause: pause,\n        register: register,\n        resume: resume,\n    }\n})()\n\nexport { activityListener }\n"],"names":["isRunning","registry","eventHandling","aim","type","callback","handler","procedure","get","eventOptions","options","window","document","console","warn","erase","delete","size","destroy","Object","keys","forEach","key","debug","log","clear","pause","register","ahead","done","doneDelay","enroll","delay","Map","set","event","tryCatch","error","setTimeout","execute","passive","capture","resume"],"mappings":"wPAAyB,WAErB,IAAIA,GAAY,EAEhB,MAAMC,EAAW,GAgCXC,EAAgB,SAAUC,EAAKC,EAAMC,GACvC,MAAMC,EAAU,KAAKF,IACfG,EAAYN,EAASG,GAAMI,IAAIH,GAAUE,UACzCE,EAAeR,EAASG,GAAMI,IAAIH,GAAUK,QAC9CJ,KAAWK,OACXA,OAAOR,EAAM,iBAAiBC,EAAMG,EAAWE,GACxCH,KAAWM,SAClBA,SAAST,EAAM,iBAAiBC,EAAMG,EAAWE,GAClC,QAARN,GACPU,QAAQC,KAAK,6BAA6BV,YAsC5CW,EAAQ,SAAUX,EAAMC,GAC1BH,EAAc,SAAUE,EAAMC,GAC9BJ,EAASG,GAAMY,OAAOX,GACjBJ,EAASG,GAAMa,aACThB,EAASG,IAOlBc,EAAU,WACZC,OAAOC,KAAKnB,GAAUoB,SAASjB,IAC3B,IAAK,IAAIkB,KAAOrB,EAASG,GAAMgB,OAC3BL,EAAMX,EAAMkB,OAmBxB,MAAO,CACHC,MAAO,IAAMV,QAAQW,IAAI,WAAYvB,GACrCwB,MAAOP,EACPA,QAASA,EACTH,MAAOA,EACPW,MATU,WACV1B,GAAY,GASZ2B,SAlEa,SAAUvB,EAAMwB,EAAOC,EAAMC,EAAY,IACtD,MAAMC,EAAS,SAAU1B,EAAUK,EAASsB,GAInC/B,EAASG,KACVH,EAASG,GAAQ,IAAI6B,KAEzBhC,EAASG,GAAM8B,IAAI7B,EAAU,CACzBE,UAPc,SAAU4B,IA/CpB,SAAU9B,EAAU2B,EAAOG,GACvC,IAAKnC,EACD,OAEJ,MAAMoC,EAAW,WACb,IACI/B,EAAS8B,GACX,MAAOE,GACLxB,QAAQwB,MAAM,6CAGjBL,EAGDM,WAAWF,EAAUJ,GAFrBI,IAoCIG,CAAQlC,EAAU2B,EAAOG,IAOzBzB,QAASA,IAEbR,EAAc,MAAOE,EAAMC,IAE3BuB,GACAG,EAAOH,EAAO,CAAEY,SAAS,EAAMC,SAAS,GAAQ,GAEhDZ,GACAE,EAAOF,EAAM,CAAEW,SAAS,EAAMC,SAAS,GAASX,IAiDpDY,OAlBW,WACX1C,GAAY,IA1GK"}